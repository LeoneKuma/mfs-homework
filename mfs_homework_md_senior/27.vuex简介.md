# Vuex简介

## 问答题

## 代码题

## 算法题

### [24][Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

成对交换节点:给出一个链表，你需要交换相邻两个元素。
如：给出 1->2->3->4 你需要返回：2->1->4->3，你的算法必须只能使用常数级的空间，你不能修改节点里的值，只能修改节点指向。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    if(!head||!head.next){//没有节点或只有一个节点
        return head
    }
    var res=head.next;
    var preNode;
    var aftNode=head.next.next;
    var fNode=head;
    var sNode=head.next;
    while(1){
        fNode.next=aftNode;
        sNode.next=fNode;
        if(preNode){
            preNode.next=sNode;
        }
        //前进两个节点，此时fNode和sNode在链表中的位置已经变化了
        preNode=fNode;
        if(!fNode.next){
            break;
        }else{
             fNode=fNode.next;
        }
        if(!fNode.next){
            break;
        }else{
             sNode=fNode.next;
        }
        aftNode=sNode.next; 
    }
    return res;
};
```

### [23][Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个有序链表,请合并 k 个有序的链表，返回合并后的有序链表。分析和表述下你的算法的复杂度。

- 解：使用分治思想，将k个链表两两合并成k/2个链表，再两两合并成k/4个链表，总共进行logk次，假设总节点数为n，因为每次基本都要遍历所有节点，所以时间复杂度为O(nlogk),在整个过程中没有创建新的节点，空间复杂度为O(1);

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if(!l1){
        return l2;
    }
    if(!l2){
        return l1;
    }
    if(l1.val<=l2.val){
        var node=l1; 
        l1=l1.next;
    }
    else{
        var node=l2; 
        l2=l2.next;
    }
    var res=node;
    while(l1&&l2){
        if(l1.val<=l2.val){
            node.next=l1;
            l1=l1.next;
            
        }else{
            node.next=l2;
            l2=l2.next;
        }
        node=node.next;
    }
    if(l1){
        node.next=l1;
    }else if(l2){
        node.next=l2;
    }
    return res;
    
};
var mergeKLists = function(lists) {
    var step=1;
    var len=lists.length;
    if(len<=1){
        return len==0?null:lists[0];
    }
    while(step<len){
        for(var i=0;i<len;i+=step*2){
            if(lists[i+step]){
                lists[i]=mergeTwoLists(lists[i],lists[i+step]);
            }
        }
        step*=2;
    }
    return lists[0]
};
```
