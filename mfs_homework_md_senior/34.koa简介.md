# Koa简介

## 问答题

## 代码题

## 算法题

### [34]

```js
/**
 * @param {number[]} nums
 * @param {number} index
 * @return {number[]}
 */
var getRange = function (nums, index) {
    var left = index;
    var right = index;
    while (nums[left - 1] != undefined && nums[left - 1] == nums[index]) {
        left--;
    }
    while (nums[right + 1] != undefined && nums[right + 1] == nums[right]) {
        right++;
    }
    return [left, right];
}
/**
 * @param {number[]} nums
 * @param {number} left
 * @param {number} right
 * @param {number} target
 * @return {number[]}
 */
var binarySearch = function (nums, left, right, target) {
    if (right - left <= 1) { //传进一个值或两个值的序列
        if (nums[left] == target) {
            return getRange(nums, left);
        } else if (nums[right] == target) {
            return getRange(nums, right);
        } else {
            return [-1, -1];
        }
    }
    var mid = Math.floor((left + right) / 2);
    if (nums[mid] == target) {
        return getRange(nums, mid);
    }
    if (nums[mid] > nums[left]) { //如果左半部分有序
        if (target >= nums[left] && target <= nums[mid]) {
            //如果可能在左半有序部分找到
            return binarySearch(nums, left, mid, target);
        } else {
            //去右半部分找
            return binarySearch(nums, mid + 1, right, target);
        }
    } else { //左半无序，右半一定是有序的
        if (target >= nums[mid + 1] && target <= nums[right]) {
            //如果可能在右半有序部分找到
            return binarySearch(nums, mid + 1, right, target);
        } else {
            //去左半无序部分找
            return binarySearch(nums, left, mid, target);
        }

    }

}
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function (nums, target) {
    if (nums.length == 0) {
        return [-1, -1];
    }
    return binarySearch(nums, 0, nums.length - 1, target);

};
```

### [32]

```js
var longestValidParentheses = function(s) {
    if(s.length<=1){
        return 0;
    }
    var res=0;
     for(var i=0;i<s.length;){
         let tempRes=0;
         let left=0;
         let matchNum=0;
         while(s[i]){
             if(s[i]=="("){
                 left++;
             }else{
                 if(left==0){
                     i++;
                     break;
                 }else if(left==1){
                     if(matchNum!=0){//彻底闭合
                         tempRes+=matchNum;
                         matchNum=0;
                     }
                     left--;
                     tempRes+=2;
                 }else if(left>1){
                     left--;
                     matchNum+=2;
                 }  
             }
             i++;
         }
         if(left>0&&matchNum!=0){//没有彻底闭合，还原本次遍历对i的改变，并+1；
             i=i-matchNum-left+1;
         }
         if(tempRes>res){//没有彻底闭合时，tempRes=0;
             res=tempRes;
         }
     }
    return res;
};
```