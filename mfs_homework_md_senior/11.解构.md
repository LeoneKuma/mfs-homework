# 解构

## 问答题

### 1.么是解构？解构本质是什么？

- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
- 解构的本质是模式匹配，如果左边是可迭代的的数组，右边也必须是可迭代的数据解构，如果左边是无序的对象，则按照属性名来匹配，右边可以是对象，也可以是数组等可迭代的数据解构，但是如果没有对应的字段会导致解构失败，左边赋值为undefined。

### 2.什么是解构默认值？怎样使用？

- 解构默认值是在解构后，声明的变量值严格等于(===)undefine时，被赋予的值。
- 只需要在解构的表达式左边的变量处用赋值符号就能给解构设置默认值。

    ```js
    var [a,b=2]=[1] //b=2;
    var [a,b=2]=[1,3]  //b=2;
    var [a,b=2]=[1,null] //b=null;
    var {a,b=2}={a:1} //b=2;
    var {a,c:b=2}={a:1,c:3} //b=3;
    // var{a,b}是简写的模式匹配，等效于var{a:a,b:b}
    ```

### 3.下面代码执行会报错吗？为什么？

```js
let foo;
let {foo} = {foo: 1};
```

- 会，因为解构前加var,let,const相当于重新声明一个变量并赋值，let和const声明的变量不允许重新声明。

### 4.下面代码执行结果是什么？会报错吗？

```js
const {"0": a,"1": b} = ["foo", "bar"];
```

- 不会报错，执行结果为a等于"foo",b等于"bar"
- 数组是可迭代的数据结构，它同时也是一个对象，数组的每一个数据，它的下标相当于对象中的属性名。所以上述解构表达式和下面的解构表达式有相同的效果：

    ```js
    const {"0": a,"1": b}={0:"foo",1:"bar"}
    ```

    或者

    ```js
    const {"0": a,"1": b}={"0":"foo","1":"bar"}
    ```

### 5.下面代码声明了几个变量？值是多少？

```js
let { a: { b: { c }}} = { a: { b: { c: "1",d: "2"}}}
```

- 声明了一个变量c,值为"1"，a和b均为模式，不是变量

### 6.数组解构的核心是什么？请自学 Generator 函数 回答下面代码返回什么

```js
function* count() {
   let i = 1
   while (true) {
      yield i++;
   }
}

let [first, second, third, fourth, fifth, sixth] = count();
```

- 数组解构的核心是等号右边应该是一个可迭代的数据结构，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

- first到sixth依次为1,2,3,4,5,6

### 7.字符串可以解构吗？结合下面代码说说为什么？

```js
const [a, b, c, d, e] = 'hello';
```

- 字符串可以解构，因为字符串也是可以迭代的数据结构，一个字符串迭代，依次返回它的每一个字符，上述解构赋值结果为 a:"h",b:"e",c:"l",d:"l",e:"o"

## 代码题

### 1.请使用解构语法实现交换两个数

```js
let a=1;
let b=2;
[a,b]=[b,a] //a=2,b=1;
```

### 2.请使用解构语法实现获取斐波那契数列前10个数

```js
function* fib(){
    let a=1;
    let b=0;
    while(true){
        [a,b]=[b,a+b];
        yield b;
    }
}

var [f1,f2,f3,f4,f5,f6,f7,f8,f9,f10]=fib();
```

### 3.对于单参数函数，如果通过解构语法设置默认值，修改代码实现默认值b = 10

```js
function test({a,b}){
   console.log(a,b)
}
```

```js
function test({a,b=10}){
   console.log(a,b)
}
```
